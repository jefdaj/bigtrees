{-# LANGUAGE BangPatterns        #-}
{-# LANGUAGE DeriveGeneric       #-}
{-# LANGUAGE FlexibleInstances   #-}
{-# LANGUAGE InstanceSigs        #-}
{-# LANGUAGE ScopedTypeVariables #-}

module System.Directory.BigTrees.HashTree.Base where

import Control.DeepSeq (NFData)
import qualified Data.ByteString.Char8 as B8
import qualified Data.ByteString.Short as BS
import Data.Char (toLower)
import Data.List (nubBy, sort)
import GHC.Generics (Generic)
import System.Directory.BigTrees.Hash (Hash (unHash), hashBytes)
import System.Directory.BigTrees.HashLine (HashLine (..), IndentLevel (..), TreeType (..), ModTime(..), Size(..))
import System.Directory.BigTrees.Name (Name (..), fp2n, n2fp)
import System.Info (os)
import Test.QuickCheck (Arbitrary (..), Gen, choose, resize, sized, suchThat)
import TH.Derive (Deriving, derive)
import Data.Time.Clock.POSIX (getPOSIXTime, utcTimeToPOSIXSeconds)

-- import Debug.Trace

-- for comparing two trees without getting hung up on different overall names
-- TODO when was this needed?
renameRoot :: FilePath -> ProdTree -> ProdTree
renameRoot newName tree = tree { name = fp2n newName }

-- for removing duplicate filenames using nubBy, taking into account
-- case-insensitivity on apple filesystem
duplicateNames :: HashTree a -> HashTree a -> Bool
duplicateNames = if os == "darwin" then macDupes else unixDupes
  where
    macDupes  a b = map toLower (n2fp $ name a)
                 == map toLower (n2fp $ name b)
    unixDupes a b = n2fp (name a)
                 == n2fp (name b)

-- TODO Integer? not sure how big it could get
totalINodes :: HashTree a -> Int
totalINodes (File {}) = 1
totalINodes (Dir {nINodes=n}) = n -- this includes 1 for the dir itself

-- TODO is this needed, or will the fields be total?
-- TODO size unit
totalSize :: HashTree a -> Integer
totalSize (File {}) = undefined -- TODO add size field
totalSize (Dir  {}) = undefined -- TODO add size field

-- TODO is this needed?
totalModTime :: HashTree a -> Integer
totalModTime (File {}) = undefined -- TODO add mod time field
totalModTime (Dir  {}) = undefined -- TODO add mod time field

hashContents :: [HashTree a] -> Hash
hashContents = hashBytes . B8.unlines . sort . map (BS.fromShort . unHash . hash)

{- A tree of file names matching (a subdirectory of) the annex,
 - where each dir and file node contains a hash of its contents.
 - TODO read and write files
 - TODO would also storing the number of files in each dir help, or timestamps?
 -}
-- data HashTree = DT.AnchoredDirTree Hash
--   deriving (Eq, Read, Show)
--   TODO rename name -> path?
--   TODO make safe access fns and don't export the partial constructors
data HashTree a
  = File
      { name     :: !Name
      , hash     :: !Hash
      , modTime  :: !ModTime
      , fileData :: !a
      -- implicitly has one inode
      }
  | Dir
      { name     :: !Name
      , hash     :: Hash -- TODO strict?
      , modTime  :: !ModTime
      , contents :: [HashTree a] -- TODO rename dirContents?
      , nINodes  :: Int -- TODO strict?
      }
  deriving (Generic, Ord, Read, Show)

-- We only need the file decoration for testing, so we can leave it off the production types
type ProdTree = HashTree ()

-- TODO disable this while testing to ensure deep equality?
instance Eq (HashTree a) where
  (==) :: HashTree a -> HashTree a -> Bool
  t1 == t2 = hash t1 == hash t2

-- TODO once there's also a dirData, should this be BiFunctor instead?
-- TODO should this also re-hash the file, or is that not part of the fileData idea?
instance Functor HashTree where
  fmap :: (a -> b) -> HashTree a -> HashTree b
  fmap fn f@(File {}) = f { fileData = fn (fileData f) }
  fmap fn d@(Dir  {}) = d { contents = map (fmap fn) (contents d) }

-- TODO test functor identity law

instance NFData a => NFData (HashTree a)

-- A HashTree where file contents are generated by QuickCheck and stored in
-- memory for round-trip tests
type TestTree = HashTree B8.ByteString

-- Given a size "budget", generate test directory contents
-- TODO write this using a fold with accumulator? wait, maybe no need
-- this should have sum of nINodes == size... or is it nINodes-1?
-- TODO test prop for that
arbitraryContents :: Int -> Gen [TestTree]
arbitraryContents size = arbitraryContentsHelper size `suchThat` uniqNames
  where
    uniqNames cs = cs == nubBy duplicateNames cs

arbitraryContentsHelper :: Int -> Gen [TestTree]
arbitraryContentsHelper size
  | size <  1 = return []
  | size == 1 = arbitraryFile >>= \t -> return [t] -- TODO clean this up
  | otherwise = do
      recSize <- choose (1,size) -- TODO bias this to be smaller?
      let remSize = size - recSize
      (recTree :: TestTree) <- resize recSize arbitrary
      arbitraryContents remSize >>= \cs -> return $ recTree:cs -- TODO clean this up

-- TODO does forAll add anything here that I'm not already getting from sized?
prop_arbitraryContents_length_matches_nINodes :: Gen Bool
prop_arbitraryContents_length_matches_nINodes =
  sized $ \size -> do
    cs <- arbitraryContents size
    let sumFiles = sum $ map totalINodes cs
        res = sumFiles == size
    -- This verifies that it gets called with the full range of sizes:
    -- return $ traceShow ((size, sumFiles)) res
    return res

-- TODO make this explicit? it's the same as the overall Arbitrary instance
-- arbitraryTree :: Int -> Gen TestTree

-- size == nINodes, so a file is always sized 1
-- TODO should these all be strict?
arbitraryFile :: Gen TestTree
arbitraryFile = do
  n  <- arbitrary :: Gen Name
  bs <- arbitrary :: Gen B8.ByteString
  mt <- arbitrary :: Gen ModTime
  return $ File
    { name = n
    , hash = hashBytes bs
    , modTime = mt
    , fileData = bs
    }

arbitraryDirSized :: Int -> Gen TestTree
arbitraryDirSized size = do
  n  <- arbitrary :: Gen Name
  -- !cs <- nubBy duplicateNames <$> resize (s `div` 2) (arbitrary :: Gen [TestTree])
  -- TODO put back the nubBy part!
  !cs <- arbitraryContents size -- TODO (s-1)?
  !mt <- arbitrary :: Gen ModTime
  -- TODO assert that nINodes == s here?
  return $ Dir
    { name     = n
    , hash     = hashContents cs
    , modTime  = mt
    , contents = cs
    , nINodes   = sum $ map totalINodes cs
    }

-- This is specialized to (HashTree B8.ByteString) because it needs to use the
-- same arbitrary bytestring for the file content and its hash
instance Arbitrary TestTree where

  arbitrary :: Gen TestTree
  arbitrary = sized $ \size -> do
    if size < 2 -- TODO can it go below 1?
      then arbitraryFile
      else arbitraryDirSized size

    -- n <- arbitrary :: Gen Name
    -- TODO there's got to be a better way, right?
    -- i <- choose (0,5 :: Int)
    -- if i == 0
      -- then arbitraryDirSized s
      -- else arbitraryFile

 -- only shrinks the filename
  shrink :: TestTree -> [TestTree]
  shrink f@(File {}) = map (\n -> f { name = n }) (shrink $ name f)

  -- shrinks either the name or the contents, and adjusts the rest to match
  -- TODO any need to recurse manually into contents?
  shrink d@(Dir {}) = newContents ++ newNames
    where
      newNames = map (\n -> d { name = n }) (shrink $ name d)
      newContents = map (\cs -> d { contents = cs
                                  , hash = hashContents cs
                                  , nINodes = sum $ map totalINodes cs}) -- TODO +1?
                        (shrink $ contents d)

-- TODO rename the actual function file -> fileData to match future dirData
-- TODO rewrite this in terms of a generic map/fold so it works with other types
dropFileData :: HashTree a -> ProdTree
dropFileData d@(Dir {contents = cs}) = d {contents = map dropFileData cs}
dropFileData f@(File {})             = f {fileData = ()}

instance Arbitrary ProdTree where
  arbitrary :: Gen ProdTree
  arbitrary = fmap dropFileData (arbitrary :: Gen TestTree)

confirmFileHashes :: TestTree -> Bool
confirmFileHashes (File {fileData = f, hash = h}) = hashBytes f == h
confirmFileHashes (Dir {contents = cs})           = all confirmFileHashes cs

prop_confirm_file_hashes :: TestTree -> Bool
prop_confirm_file_hashes = confirmFileHashes
